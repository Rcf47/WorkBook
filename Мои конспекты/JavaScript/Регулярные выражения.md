# Регулярные выражения

```jsx
let petString = "James has a pet cat"
let petRegex = /dog|cat|bird|fish/
let result = petRegex.test(petString) // возвращает true or false в зависимости найдет ли выражение
```

/dog|cat|bird|fish/ = строка из нескольких примеров поиска

/freecodecamp/i ← i - это флаг означает ignorecase (.test вернет true для freecodecamp)

```jsx
let testStr = "Repeat, Repeat, Repeat"
let ourRegex = /Repeat/;
testStr.match(ourRegex) // проверяет есть ли выражение в строке
```

.match возвращает найденный элемент, если элементов несколько, то возвращает массив элементов.

/Repeat/g - флаг g - означает global, т.е поиск несколькоих значений.

/hu./ ← означает любую букву, верно для hug, hum

/b[aeu]g/ - [ ] ← список возможной буквы

/[aeui]/ig - найдет гласные a e u i независимо от регистра.

/[a-z]/ - range of letters, с флагом g найдет  все маленькие буквы

/[2-6h-s]/ - ренж цифр и букв

/[^0-9aeiou]/ig - исключаем цифры и гласные

/s+/g - s один или более раз

/go*/ - вернуть буквы 0 или более раз

“gut feeling”.match(Regex) - вернет “g”, а “о” как ноль раз

/Aa*/ - Aa встречается ноль или более раз

---

let string = “titanic”

let regex = /t[a-z]*?i/ - ? означает lazy метод поиска

string.match(regex) -вернет ti, без ? вернет titani

lazy  - возвращает сразу ближайший выход из регулярного выражения. greed смотрит всю строку

---

/^cal/ - ^ означает начало строки

/caboose$/ - $ означает конец строки

/\w/g - найти любые буквы и цифры ( тоже самое, что и /[0-9a-z]/i

/\W/g - логическое не, т.е не будкуы и цифры ( найдет пробелы и точки)

/\d/g - найти все цифры

/\D/g - логическое не, найти все не цифры

\b - граница слова

---

{2, } ← 2 минимум сколько раз, пустое место максимум сколько раз, тут бесконечность.

{} ← означает требование к предыдущей букве

/^[a-zA-Z]{2,}\d*$/ ← найдет все имен, где минимум две буквы, не важно, большие или маленькие и цифры в конце

---

/\s/g - найти все пробелы

/\S/g - найти все не пробелы

{4} - точное совпадение, точно 4 раза

/favou?rite/ - ? “u” может быть, а может  и не быть

---

/q(?=u)/ - позитивный вариант. ? означает lookahead

/q(?!u)/ - негативный вариант

---

/(\w+)\s\1/ - ( ) группируем \1 - вызываем еще раз

/(\w+)\s\1/ = /(\w+)\s(\w)/ одно и тоже

\1 ← номер группы может дальше \2 \3

---

wrongText.replace( regex, “ “)

regex ← что меняем

пустая строка ← на что меняем

wrongText.replace(/(\w+)\s(\w+)/, “$2 $1”) - перестановка слов в результате. $2 $1 ← номер групп

$2 $1 ← тут можно добавлять слова через $

---

/ ^\s+|\s+$/g ← означает пробелы в начале или в конце, флаг g пройдет по всей строке.